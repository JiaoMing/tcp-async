<html>
<head>
    <title>Hello Scala - Activator Template</title>
</head>
<body>

<div>
    <h2> Introduction </h2>
    <p>
        tcp-async, as you can understand from the name, handles tcp requests asynchronously with 
        <a href="http://www.akka.io">AkkaIO</a>.
    </p>
    <p> 
        Thanks to akka-io, <code>tcp-handler</code> can respond high amount of requests simultaneously. Whole app have an asynchronous design.
    </p>

    <p>
        We've created a few options for handling requests. Writing incoming data to a mysql database, making an Api call,
        and an echoserver from the simplest. 
        For those handlers we've used some open source libraries which will be mentioned later.
    </p>

    <img src="tutorial/tcp-async.png" style="width:400px">

    <p>
        For further information about used technologies, please refer to References section.
</div>

<div>
    <h2> First things first: Main </h2>

    <p>
        The enterance of our application contain two lines of code.
        First, an <a href="http://doc.akka.io/docs/akka/2.0/general/actor-systems.html">Actor System</a> definition:
            <pre><code>
                val system = ActorSystem("server")
            </code></pre>
    </p>

    <p>
        And a Server actor definition which is our next subject:
        <pre><code>
            val service = system.actorOf(TcpServer.props(), "ServerActor")
        </code></pre>
    </p>

</div>

<div>
    <h2> Handling Requests: Server</h2>
    <p> 
        <a href="#code/src/main/scala/server/Server.scala" class="shortcut">Server</a>
        is an actor which listen requests and decide what to do with incoming request.
        This could be a Htpp, Tcp or Udp request. You should implement a Server actor for the type you wish to use. 
        <code>tcp-async</code> have a
        <a href="#code/src/main/scala/server/TcpServer.scala" class="shortcut">TcpServer</a> 
        as default. 
    </p>

    <p>
        Every 
        <a href="#code/src/main/scala/server/Server.scala" class="shortcut">Server</a>
        actor binds to an InetSocketAdress. In this case,
        <a href="#code/src/main/scala/server/TcpServer.scala" class="shortcut">TcpServer</a>
        listens incoming Tcp requests with following binding:
        <pre><code>
            IO(Tcp) ! Bind(self, new InetSocketAddress(Conf.appHostName, Conf.appPort))
        </code></pre>
    </p>
    

    <p>
        HostName and port comes from 
        <a href="#code/src/main/resources/application.conf" class="shortcut">configuration</a>
        file which we will see later.
    </p>

    <p>
        Just below that, you can see <code>recieve()</code> method:
    </p>

    <pre><code>
        override def receive = {
            case CommandFailed(_: Bind) => context stop self

            case Connected(remote, local) =>
              val handler = context.actorOf(ApiHandler.props(sender))
              sender ! Register(handler)
        }
    </code></pre>

    <p>
        <code>recieve()</code> creates a new
        <a href="#code/src/main/scala/handler/Handler.scala" class="shortcut">Handler</a> 
        and registers it to sender. Which means server creates a connection with sender.
        But the key part here is that connection with sender(client) is not made by server itself.
        Every connection is handled by a Handler actor.
        That means Server actor doesn't need to deal with all connections. 
        Thus there is no impediment about connection count. According to some tests that we've made, 
        10k requests can be easily handled by tcp-async.
    </p>

    <p>
        Remember, 10k actors doesn't mean 10k threads.
    </p> 

    <p>
        Handlers are will be described next.
    </p> 
</div>

<div>
    <h2>Deciding what to do: Handlers</h2>

    <p>
        <a href="#code/src/main/scala/handler/Handler.scala" class="shortcut">Handler</a> is trait and it extended Actor class. In other words Handler is a Actor.
        Your handler classes should implemented by extending the 
        Handler class and implementing the receive method. The receive method should define a series of case statements that defines which messages your handler can handle, using standard Scala pattern matching, along with the implementation of how the messages should be processed.
    </p>

    <h3> Props </h3>
    <p>
        Props is a configuration class to specify options for the creation of actors. Here is an example how to create Props.
        <pre><code>
            import akka.actor.Props
        
            val props1 = Props[MyActor]
            val props2 = Props(classOf[MyActor], args)
        </code></pre>
    </p>

    <h3> Create an Handler </h3>
    <pre><code>
        object DemoActor {
          def props(connection: ActorRef): Props = 
            Props(classOf[DemoActor], connection)
        }
         
        class DemoHandler(connection: ActorRef) extends Handler {
          override def receive = {
            case x â‡’ // some behavior
          }
        }
    </code></pre>
    <p>
        This is recommended usage for creating an Actor so an handler class creating in this way.
    </p>
</div>

<div>
    <h2> Received Data </h2>
    <p> 
        This classes are an handler and extended <a href="#code/src/main/scala/handler/Handler.scala" class="shortcut">Handler</a> trait. 
        Every handler class must extended Handler and implementing received method. This method handle massages.
        Tcp messages received with <code> case Received(data) => // Process </code>. Incoming data is ByteString and contain end of the message new line character. If you convert it to string you should this method. <code>data.utf8String.trim</code> 
    </p>

    <pre><code>
        def receive = {
            case Received(data) => {
              val text = data.utf8String.trim
              val sendText = text + " ok!"
              text match {
                case "close" => context.stop(self)
                case _ => connection ! Write(ByteString(sendText))
              }
            }

            case _: ConnectionClosed =>
              context.stop(self)

            case PeerClosed => context stop self
        }   
    </code></pre>

    <p>
        In this case <code> Received(data) </code> handle TCP messages and incoming messages type is String. Handled tcp data convert to String and implement pattern matching. If data equals "close", stop context else send data to client. <code>connection ! Write(ByteString(sendText))</code>.
    </p>
</div>

</body>
</html>
