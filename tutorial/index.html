<html>
<head>
    <title>Hello Scala - Activator Template</title>
</head>
<body>

<div>
    <h2> Introduction </h2>
    <p>
        tcp-async, as you can understand from the name, handles tcp requests asynchronously with 
        <a href="http://www.akka.io">AkkaIO</a>.
    </p>
    <p> 
        Thanks to akka-io, <code>tcp-handler</code> can respond high amount of requests simultaneously. Whole app have an asynchronous design.
    </p>

    <p>
        We've created a few options for handling requests. Writing incoming data to a mysql database, making an Api call,
        and an echoserver for the simplest. 
        For those handlers we've used some open source libraries which will be mentioned later.
    </p>

    <img src="tutorial/tcp-async.png" style="width:400px">

    <p>
        For further information about used technologies, please refer to References section.
</div>

<div>
    <h2>Before Diving In</h2>

    <p>
        You should know some basic structures before scrolling around the template:
    </p>

    <h3>Config</h3>
    
    <p> Every configuration data stands in 
        <a href="#code/src/main/resources/application.conf" class="shortcut">application.conf</a>.
        This helps us to keep all configurations together.
    </p>

    <p> 
        At the starting of the application, all configurations is loaded to a
        <a href="#code/src/main/scala/util/Conf.scala" class="shortcut">Conf</a> object. 
        Application uses this object when needed instead of reading <code>.conf</code> file every time.

        <pre><code>
            val uri = Conf.apiUrl + data.utf8String.trim()
            // Instead of:
            // val config = ConfigFactory.load()
            // config.checkValid(ConfigFactory.defaultReference())
            // val uri = config.getString("api.url") + data.utf8String.trim()
        </code></pre>

        For more information, please see 
        <a href="https://github.com/typesafehub/config">typesafe config</a>. 
        
    </p>

    <h3>Props</h3>
    
    <p>
        Props is a configuration class to specify options for the creation of actors. 
        Here is some examples for how to create Props:
        <pre><code>
            import akka.actor.Props
        
            val props1 = Props[MyActor]
            val props2 = Props(classOf[MyActor], args)
        </code></pre>
    </p>

    <p>
        Recommended usage for creating an Actor is:
    </p>
    <pre><code>
        object DemoActor {
          def props(args): Props = 
            Props(classOf[DemoActor], args)
        }

        class DemoActor(args) extends Actor {
          override def receive = {
            case x â‡’ // some behavior
          }
        }

        context.actorOf(DemoActor.props(args))
    </code></pre>

</div>

<div>
    <h2> First Things First: Main </h2>

    <p>
        The enterance of our application contain two lines of code.
        First, an <a href="http://doc.akka.io/docs/akka/2.0/general/actor-systems.html">Actor System</a> definition:
            <pre><code>
                val system = ActorSystem("server")
            </code></pre>
    </p>

    <p>
        And a Server actor definition which is our next subject:
        <pre><code>
            val service = system.actorOf(TcpServer.props(), "ServerActor")
        </code></pre>
    </p>

</div>

<div>
    <h2> Handling Connections: Server</h2>
    <p> 
        <a href="#code/src/main/scala/server/Server.scala" class="shortcut">Server</a>
        is an actor which listen connections .
        This could be a Htpp, Tcp or Udp request. You should implement a Server actor for the type you wish to use. 
        <code>tcp-async</code> have a
        <a href="#code/src/main/scala/server/TcpServer.scala" class="shortcut">TcpServer</a> 
        within. 
    </p>

    <p>
        Every 
        <a href="#code/src/main/scala/server/Server.scala" class="shortcut">Server</a>
        actor binds to an InetSocketAdress. In this case,
        <a href="#code/src/main/scala/server/TcpServer.scala" class="shortcut">TcpServer</a>
        listens incoming Tcp requests with following binding:
        <pre><code>
            IO(Tcp) ! Bind(self, new InetSocketAddress(Conf.appHostName, Conf.appPort))
        </code></pre>
    </p>

    <p>
        Just below that, you can see <code>recieve()</code> method:
    </p>

    <pre><code>
        override def receive = {
            case CommandFailed(_: Bind) => context stop self

            case Connected(remote, local) =>
              val handler = context.actorOf(ApiHandler.props(sender))
              sender ! Register(handler)
        }
    </code></pre>

    <p>
        <code>recieve()</code> creates a new
        <a href="#code/src/main/scala/handler/Handler.scala" class="shortcut">Handler</a> 
        and registers it to sender. Which means server creates a connection with sender.
        But the key part here is that connection with sender(client) is not managed by server itself.
        Every connection is handled by a Handler actor instance.
        That means Server actor doesn't need to deal with them. 
        Thus there is no impediment about connection count. According to some tests that we've made, 
        10k requests can be easily handled by tcp-async.
    </p>

    <p><i>
        Remember, 10k actors doesn't mean 10k threads.
    </i></p> 

    <p>
        Handlers will be described next.
    </p> 
</div>

<div>
    <h2>Deciding What To Do: Handler</h2>

    <p>
        <a href="#code/src/main/scala/handler/Handler.scala" class="shortcut">Handler</a> is an Actor that decide what to do with incoming request. The receive method should define a series of case statements that
        decides which messages your handler can handle, using standard Scala pattern matching, along with the implementation
        of how the messages should be processed.
    </p>

    <p>
        Handling requests managed in <code>receive</code> method.

        <pre><code>
            def receive = {
                case Received(data) => {
                    // Do something
                }
                
                case PeerClosed => context stop self
            }
        </code></pre>

        <code> Received </code> case defines what to do with successfully recieved data.

        Incoming data is ByteString and contains a new line character at the end. Thats why we convert and trim it before use:
         <pre><code>
            val convertedData = data.utf8String.trim
         </code></pre>
    </p>

    <p> tcp-async contains three type of handlers: </p>
        <a href="#code/src/main/scala/handler/EchoHandler.scala" class="shortcut">EchoHandler</a>
        
        <p>

        </p>
        
        <br />
        <a href="#code/src/main/scala/handler/DbHandler.scala" class="shortcut">DbHandler</a>
        <br />
        <a href="#code/src/main/scala/handler/ApiHandler.scala" class="shortcut">ApiHandler</a>


    

    
</div>

<div>
    <h2> Received Data </h2>
    <p> 
        This classes are an handler and extended <a href="#code/src/main/scala/handler/Handler.scala" class="shortcut">Handler</a> trait. 
        Every handler class must extended Handler and implementing received method. This method handle massages.
        Tcp messages received with <code> case Received(data) => // Process </code>. Incoming data is ByteString and contain end of the message new line character. If you convert it to string you should this method. <code>data.utf8String.trim</code> 
    </p>

    <pre><code>
        def receive = {
            case Received(data) => {
              val text = data.utf8String.trim
              val sendText = text + " ok!"
              text match {
                case "close" => context.stop(self)
                case _ => connection ! Write(ByteString(sendText))
              }
            }

            case _: ConnectionClosed =>
              context.stop(self)

            case PeerClosed => context stop self
        }   
    </code></pre>

    <p>
        In this case <code> Received(data) </code> handle TCP messages and incoming messages type is String. Handled tcp data convert to String and implement pattern matching. If data equals "close", stop context else send data to client. <code>connection ! Write(ByteString(sendText))</code>.
    </p>
</div>

</body>
</html>
